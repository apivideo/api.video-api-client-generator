import { expect } from 'chai';
import ApiVideoClient from '../src';
{{#models}}
{{#model}}
import {{classFilename}} from '../{{ modelPackage }}/{{classFilename}}';
{{/model}}
{{/models}}

const timeout = (ms = 100) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, ms);
  });

try {
  if (!process.env.API_KEY) {
    console.error(
      'You must provide `API_KEY` environment variable to test the sandbox.'
    );
    console.log('API_KEY=xxx yarn test:sandbox');

    process.exit(1);
  }
} catch (e) {
  console.error(e);
  process.exit(1);
}

describe('ApiVideoClient', () => {
  it('works with the sandbox', async () => {
    // Create client for Sandbox and authenticate
    const client = new ApiVideoClient({
        apiKey: process.env.API_KEY,
        baseUri: process.env.BASE_URI,
        chunkSize: 5*1024*1024
    });

    // Create
    const progressiveUploadVideo = 'Nodejs - progressive upload';
    const { videoId: progressiveUploadVideoId } = await client.videos.create({
      title: progressiveUploadVideo,
    });

    // Progressive upload
    const progressiveUploadSession = client.videos.createUploadProgressiveSession(progressiveUploadVideoId);
    await progressiveUploadSession.uploadPart("test/data/10m.mp4.part.a");
    await progressiveUploadSession.uploadPart("test/data/10m.mp4.part.b");
    await progressiveUploadSession.uploadLastPart("test/data/10m.mp4.part.c")
      .then((video) => {
        expect(video.title).to.equals(progressiveUploadVideo);
      });
    await client.videos.delete(progressiveUploadVideoId);


    // Create an upload token
    const { token: progressiveUploadToken } = await client.uploadTokens.createToken();
    // Progressive upload
    const progressiveUploadWithTokenSession = client.videos.createUploadWithUploadTokenProgressiveSession(progressiveUploadToken as string);
    await progressiveUploadWithTokenSession.uploadPart("test/data/10m.mp4.part.a");
    await progressiveUploadWithTokenSession.uploadPart("test/data/10m.mp4.part.b");
    await progressiveUploadWithTokenSession.uploadLastPart("test/data/10m.mp4.part.c")
      .then((video) => {
        expect(video.title).to.equals("10m.mp4.part.a");
        client.videos.delete(video.videoId);
      });

    // Create
    const videoTitle = 'Course #4 - Part B';
    const { videoId, title } = await client.videos.create({
      title: videoTitle,
    });

    // upload a video resource
    await client.videos
      .upload(videoId, 'test/data/558k.mp4')
      .then((video) => {
        expect(title).to.equals(videoTitle);
      });

    // Update video properties
    const newDescription = 'Course #4 - Part C';
    await client.videos
      .update(videoId, { description: newDescription })
      .then((video) => {
        expect(video.description).to.equals(newDescription);
      });

    // Search videos with paginated results
    await client.videos
      .list({ currentPage: 1, pageSize: 100 })
      .then(({ data: videos }) => {
        expect(videos).to.be.an('array');
        expect(
          videos.findIndex((v) => v.videoId === videoId) !== -1,
          'To find the previously created video in the list.'
        ).to.be.true;
      });

    // Upload a video thumbnail
    await client.videos
      .uploadThumbnail(videoId, 'test/data/test.jpg')
      .then((video) => expect(video.videoId).to.equals(videoId));

    // Pick a thumbnail from the given time code.
    await client.videos
      .pickThumbnail(videoId, { timecode: '00:15:22.05' })
      .then((video) => expect(video.videoId).to.equals(videoId));

    // Upload video caption
    await client.captions
      .upload(videoId, 'en', 'test/data/en.vtt')
      .then((caption) => expect(caption.srclang).to.equals('en'));

    await timeout(1000);

    // Get video caption by language
    await client.captions
      .get(videoId, 'en')
      .then((caption) => expect(caption.src).to.be.a('string'));

    // Update the default caption language
    await client.captions
      .update(videoId, 'en', { _default: true })
      .then((caption) => {
        expect(caption.srclang).to.equals('en');
        expect(caption._default).to.equals(true);
      });

    // Delete caption by language
    await client.captions.delete(videoId, 'en');

    // Upload video chapter
    await client.chapters
      .upload(videoId, 'en', 'test/data/en.vtt')
      .then((chapter) => expect(chapter.language).to.equals('en'));

    await timeout(1000);

    // Get video chapter by language
    await client.chapters
      .get(videoId, 'en')
      .then((chapter) => expect(chapter.language).to.equals('en'));

    // Delete chapter by language
    await client.chapters.delete(videoId, 'en');

    // Get video Analytics Data for the current year
    await client.rawStatistics
      .listVideoSessions({
        videoId,
        period: new Date().getFullYear().toString(),
        metadata: {'user': 'username'},
      })
      .then(({ data: videoSessions }) =>
        expect(videoSessions).to.be.an('array')
      );

    // Delete video resource
    await client.videos.delete(videoId);

    // Create a player theme with a custom name
    const playerThemeName = "my player theme";
    const theme = await client.playerThemes.create({ name: playerThemeName });
    expect(theme.playerId).to.be.a('string');

    // Get a playerTheme
    await client.playerThemes.get(theme.playerId).then((playerTheme) => {
      expect(theme.playerId).to.equals(playerTheme.playerId);
      expect(playerThemeName).to.equals(playerTheme.name);
    });

    // Search a player theme with paginate results
    await client.playerThemes
      .list({ currentPage: 1, pageSize: 50 })
      .then(({ data: playerThemes }) => expect(playerThemes).to.be.an('array'));

    const properties: PlayerThemeUpdatePayload = {
      text: 'rgba(255, 255, 255, .95)',
      link: 'rgba(255, 0, 0, .95)',
      linkHover: 'rgba(255, 255, 255, .75)',
      trackPlayed: 'rgba(255, 255, 255, .95)',
      trackUnplayed: 'rgba(255, 255, 255, .1)',
      trackBackground: 'rgba(0, 0, 0, 0)',
      backgroundTop: 'rgba(72, 4, 45, 1)',
      backgroundBottom: 'rgba(94, 95, 89, 1)',
      backgroundText: 'rgba(255, 255, 255, .95)',
      enableApi: true,
      enableControls: true,
      forceAutoplay: false,
      hideTitle: true,
      forceLoop: true,
    };

    await client.playerThemes
      .update(theme.playerId, properties)
      .then((playerTheme) => {
        Object.keys(properties).forEach((property) => {
          // @ts-ignore
          expect(playerTheme).to.have.property(property, properties[property]);
        });
      });

    await client.playerThemes
      .uploadLogo(theme.playerId, 'test/data/test.jpg', 'https://api.video')
      .then((playerTheme) =>
        expect(playerTheme.assets?.link).to.equals('https://api.video')
      );

    await client.playerThemes.delete(theme.playerId);

    // Create a live
    const name = 'This is a live';
    const { liveStreamId, name: liveName } = await client.liveStreams.create({
      name,
    });
    expect(liveName).to.equals(name);

    // Update live thumbnail
    await client.liveStreams
      .uploadThumbnail(liveStreamId, 'test/data/test.jpg')
      .then((live) => expect(live.name).to.equals(name));

    // Get live Analytics Data for the current year
    await client.rawStatistics
      .listLiveStreamSessions({
        liveStreamId,
        period: new Date().getFullYear().toString(),
      })
      .then(({ data: liveStreamSessions }) =>
        expect(liveStreamSessions).to.be.an('array')
      );

    // Delete live resource
    await client.liveStreams.delete(liveStreamId);

    // Create a private live
    const {
      liveStreamId: privateLiveStreamId,
      _public: isPublic,
    } = await client.liveStreams.create({
      name: 'This is a private live',
      _public: false,
    });
    expect(isPublic).to.equals(false);

    // Delete the private live
    await client.liveStreams.delete(privateLiveStreamId);

    // Generate a token for delegated upload
    const { token } = await client.uploadTokens.createToken();
    expect(token).to.be.a('string');

    // Upload a video with a token
    await client.videos.uploadWithUploadToken(token as string, 'test/data/558k.mp4');
  });
});
